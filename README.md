DSA using Python Notes 
# ğŸ“˜ 100 Days of DSA - Day 01

## ğŸ” Topic: Analysis of Algorithms

### ğŸ“– Summary

On **Day 01**, I studied the fundamentals of **algorithm analysis**, including time and space complexity, Big O notation, and types of cases (best, average, worst). These are essential for evaluating the efficiency of algorithms and understanding their performance at scale.

---

### ğŸ§  Key Concepts Covered

- What is Algorithm Analysis?
- Why Analysis Matters in Software Development
- Time Complexity and Space Complexity
- Big O Notation:
  - `O(1)`, `O(n)`, `O(log n)`, `O(n log n)`, `O(nÂ²)`, etc.
- Case Analysis:
  - Best, Average, Worst Cases
- Asymptotic Analysis
- Real-world Examples (e.g., Linear Search, Binary Search)
- Types of Algorithm Analysis:
  - Theoretical, Empirical, Amortized

---

### ğŸ“„ Notes

I've created a structured, easy-to-understand PDF with all the key points and examples from today's learning.

### âœ… Outcome

- Gained clarity on how to evaluate and compare algorithm efficiency.
- Created reference notes for future review and coding practice.

---

### ğŸ“… Next: Day 02 - Comparing Orders of Magnitude and Calculating Complexity

### ğŸ“– Summary

On **Day 02**, I explored how to **compare algorithm efficiency** using **orders of magnitude** and calculate complexity using **Big-O notation**. I also reviewed how different algorithms grow as input size increases and how to analyze their time complexity step-by-step.

---

### ğŸ§  Key Concepts Covered

- What are Orders of Magnitude?
- Understanding Time and Space Complexity
- Common Time Complexities:
  - `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(nÂ²)`, `O(2â¿)`, `O(n!)`
- Why Comparing Growth Rates Matters
- Calculating Complexity from Code
- Practical Examples:
  - Single Loop â†’ `O(n)`
  - Nested Loops â†’ `O(nÂ²)`
  - Binary Search â†’ `O(log n)`
- Simplification Rules (Ignore constants, drop lower-order terms)

---

### ğŸ“ˆ Visual Aid

Included a graph to visually compare the growth of common time complexities with respect to input size.

---

### ğŸ“„ Notes

I've created a well-structured PDF with clear examples and a visual chart.

### âœ… Outcome

- Gained a deeper understanding of algorithm growth behavior
- Learned how to analyze and simplify time complexity
- Created reference notes and a chart for quick comparison

---

### ğŸ“… Next: Day 03 - Searching in a list

## ğŸ” Topic: Searching in a List & Basic Sorting Algorithms

### ğŸ“– Summary

Today I studied and implemented basic searching and sorting algorithms. These are essential tools for efficient data manipulation and understanding algorithm complexity.

---

### ğŸ” Searching Algorithms

1. **Linear Search** - Scans each element until the target is found.  
   ğŸ”¹ Time: O(n)  
   ğŸ”¹ Space: O(1)

2. **Binary Search** - Efficient search for sorted lists using divide-and-conquer.  
   ğŸ”¹ Time: O(log n)  
   ğŸ”¹ Space: O(1)

---

### ğŸ”ƒ Sorting Algorithms

3. **Selection Sort** - Finds the minimum and places it in order.  
   ğŸ”¹ Time: O(nÂ²)  
   ğŸ”¹ Space: O(1)

4. **Insertion Sort** - Builds a sorted list one element at a time.  
   ğŸ”¹ Time: O(nÂ²)  
   ğŸ”¹ Space: O(1)

5. **Merge Sort** - Recursive divide-and-merge strategy for efficient sorting.  
   ğŸ”¹ Time: O(n log n)  
   ğŸ”¹ Space: O(n)

---

### ğŸ“„ Notes

I've created a well-structured PDF with clear examples and code.

---

### âœ… Outcome

- Learned how to perform both linear and binary searches.
- Practiced selection, insertion, and merge sort with Python implementations.
- Understood their respective time and space complexities.

---

### ğŸ“… Next: Day 04 - 

