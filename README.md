DSA using Python Notes 
# 📘 100 Days of DSA - Day 01

## 🔍 Topic: Analysis of Algorithms

### 📖 Summary

On **Day 01**, I studied the fundamentals of **algorithm analysis**, including time and space complexity, Big O notation, and types of cases (best, average, worst). These are essential for evaluating the efficiency of algorithms and understanding their performance at scale.

---

### 🧠 Key Concepts Covered

- What is Algorithm Analysis?
- Why Analysis Matters in Software Development
- Time Complexity and Space Complexity
- Big O Notation:
  - `O(1)`, `O(n)`, `O(log n)`, `O(n log n)`, `O(n²)`, etc.
- Case Analysis:
  - Best, Average, Worst Cases
- Asymptotic Analysis
- Real-world Examples (e.g., Linear Search, Binary Search)
- Types of Algorithm Analysis:
  - Theoretical, Empirical, Amortized

---

### 📄 Notes

I've created a structured, easy-to-understand PDF with all the key points and examples from today's learning.

### ✅ Outcome

- Gained clarity on how to evaluate and compare algorithm efficiency.
- Created reference notes for future review and coding practice.

---

### 📅 Next: Day 02 - Comparing Orders of Magnitude and Calculating Complexity

### 📖 Summary

On **Day 02**, I explored how to **compare algorithm efficiency** using **orders of magnitude** and calculate complexity using **Big-O notation**. I also reviewed how different algorithms grow as input size increases and how to analyze their time complexity step-by-step.

---

### 🧠 Key Concepts Covered

- What are Orders of Magnitude?
- Understanding Time and Space Complexity
- Common Time Complexities:
  - `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n²)`, `O(2ⁿ)`, `O(n!)`
- Why Comparing Growth Rates Matters
- Calculating Complexity from Code
- Practical Examples:
  - Single Loop → `O(n)`
  - Nested Loops → `O(n²)`
  - Binary Search → `O(log n)`
- Simplification Rules (Ignore constants, drop lower-order terms)

---

### 📈 Visual Aid

Included a graph to visually compare the growth of common time complexities with respect to input size.

---

### 📄 Notes

I've created a well-structured PDF with clear examples and a visual chart.

### ✅ Outcome

- Gained a deeper understanding of algorithm growth behavior
- Learned how to analyze and simplify time complexity
- Created reference notes and a chart for quick comparison

---

### 📅 Next: Day 03 - Searching in a list

## 🔍 Topic: Searching in a List & Basic Sorting Algorithms

### 📖 Summary

Today I studied and implemented basic searching and sorting algorithms. These are essential tools for efficient data manipulation and understanding algorithm complexity.

---

### 🔎 Searching Algorithms

1. **Linear Search** - Scans each element until the target is found.  
   🔹 Time: O(n)  
   🔹 Space: O(1)

2. **Binary Search** - Efficient search for sorted lists using divide-and-conquer.  
   🔹 Time: O(log n)  
   🔹 Space: O(1)

---

### 🔃 Sorting Algorithms

3. **Selection Sort** - Finds the minimum and places it in order.  
   🔹 Time: O(n²)  
   🔹 Space: O(1)

4. **Insertion Sort** - Builds a sorted list one element at a time.  
   🔹 Time: O(n²)  
   🔹 Space: O(1)

5. **Merge Sort** - Recursive divide-and-merge strategy for efficient sorting.  
   🔹 Time: O(n log n)  
   🔹 Space: O(n)

---

### 📄 Notes

I've created a well-structured PDF with clear examples and code.

---

### ✅ Outcome

- Learned how to perform both linear and binary searches.
- Practiced selection, insertion, and merge sort with Python implementations.
- Understood their respective time and space complexities.

---

### 📅 Next: Day 04 - 

